## The typical approach here would be to make roxygen2 a hard
## dependency, import either the whole package or the three generics
## (roxy_tag_parse, roclet_process and roclet_output) then register
## the S3 methods with '@export' as normal.  However, this requires
## that we have roxygen2 available at runtime which is pretty weird
## given we only need it when running the package. From R 3.6.0 we can
## use the syntax below to register the methods when roxygen2 is
## loaded.
##
##' @rawNamespace S3method(roxygen2::roxy_tag_parse, roxy_tag_porcelain)
##' @rawNamespace S3method(roxygen2::roclet_process, roclet_porcelain)
##' @rawNamespace S3method(roxygen2::roclet_output, roclet_porcelain)
roxy_tag_parse.roxy_tag_porcelain <- function(x) {
  ## The first line(s) must conform to `<VERB> <PATH> => <RETURNING>
  txt <- x$raw
  re <- "^\\s*([A-Z]+)\\s+([^ =]+)\\s*=>\\s*(.*?)(\n|$)(.*)"
  if (!grepl(re, txt)) {
    stop("invalid porcelain tag")
  }
  method <- sub(re, "\\1", txt)
  path <- sub(re, "\\2", txt)
  returning <- trimws(sub(re, "\\3", txt))
  remainder <- sub(re, "\\5", txt)
  if (nzchar(remainder)) {
    ## TODO: this will need some work here.
    message("Ignoring extra porcelain input")
  }
  inputs <- NULL

  ## TODO: we will want to autoquote the arguments to this function,
  ## which might vary based on inputs (e.g. a status code of 200 might
  ## want to come through as an integer, but a schema should not need
  ## quoting).  We could respond to the actual name if need be though.
  if (!grepl("(", returning, fixed = TRUE)) {
    returning <- paste0(returning, "()")
  }
  re <- "^(.*?)\\((.*)"
  returning_type <- sub(re, "\\1", returning)
  if (!grepl("^porcelain::porcelain_returning", returning_type)) {
    ## TODO: allow a totally custom function here? Easy to do if we
    ## see the function in the package, but that would be done at
    ## roclet_process as that requires 'env'
    returning_type <- switch(
      returning_type,
      json = "porcelain::porcelain_returning_json",
      binary = "porcelain::porcelain_returning_binary",
      generic = "porcelain::porcelain_returning",
      returning_type)
    returning <- paste0(returning_type, "(", sub(re, "\\2", returning))
  }

  ## TODO: validate verb here?
  ## TODO: validate path here (harder/impossible?)
  x$val <- list(method = method,
                path = path,
                inputs = inputs,
                returning = returning)
  x
}


porcelain_roclet <- function() {
  roxygen2::roclet("porcelain")
}


roclet_process.roclet_porcelain <- function(x, blocks, env, base_path) {
  results <- character()

  for (block in blocks) {
    tags <- roxygen2::block_get_tags(block, "porcelain")
    ## TODO we'd want to make sure that there is 0 or 1 here I think.
    if (length(tags) > 0L) {
      ## TODO: nice validation on these
      stopifnot(
        length(tags) == 1,
        is.function(block$object$value))
      tag <- tags[[1]]
      ## TODO could be incorrect, check by setting this
      ## alternative locations include block$object$topic and block$call[[2]]
      target <- block$object$alias

      ## TODO, will get some parse support here.
      if (is.null(tag$val$inputs)) {
        inputs <- NULL
      } else {
        browser()
      }

      ## TODO: validate against the endpoint here so that we throw
      ## nice error messages.
      endpoint <- c(
        "porcelain::porcelain_endpoint$new(",
        sprintf('  "%s",', tag$val$method),
        sprintf('  "%s",', tag$val$path),
        sprintf("  %s,", target),
        inputs,
        sprintf("  returning = %s)", tag$val$returning))

      if (length(results) > 0L) {
        results[[length(results)]] <- paste0(results[[length(results)]], ",")
      }

      results <- c(results, endpoint)
    }
  }

  if (length(results) == 0) {
    stop("Package contains no '@porcelain' tags")
  }

  code <- c(
    "`__porcelain__` <- function() {",
    "  list(",
    paste0("    ", results),
    "  )",
    "}")

  code
}

roclet_output.roclet_porcelain <- function(x, results, base_path, ...) {
  header <- "# Generated by porcelain: do not edit by hand"

  dest <- file.path(base_path, "R", "porcelain.R")
  if (file.exists(dest)) {
    prev <- readLines(dest)
    if (length(prev) > 0 && prev[[1]] != header) {
      ## TODO: better, actionable, error
      stop("porcelain.R is not ours to change")
    }
  }

  writeLines(c(header, results), dest)

  invisible(NULL)
}

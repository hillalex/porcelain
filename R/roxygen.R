## The typical approach here would be to make roxygen2 a hard
## dependency, import either the whole package or the three generics
## (roxy_tag_parse, roclet_process and roclet_output) then register
## the S3 methods with '@export' as normal.  However, this requires
## that we have roxygen2 available at runtime which is pretty weird
## given we only need it when running the package. From R 3.6.0 we can
## use the syntax below to register the methods when roxygen2 is
## loaded, which requires that we inject some raw content into the
## namespace (see R-exts).  Each of these is above the method used so
## we provide the minimum NAMESPACE support.

porcelain_roclet <- function() {
  roxygen2::roclet("porcelain")
}


##' @rawNamespace S3method(roxygen2::roxy_tag_parse, roxy_tag_porcelain)
roxy_tag_parse.roxy_tag_porcelain <- function(x) {
  ## See roxygen_parse.R for the bulk of the implementation.
  x$val <- roxy_parse_string(x$raw, x$file, x$line)
  x
}


##' @rawNamespace S3method(roxygen2::roclet_process, roclet_porcelain)
roclet_process.roclet_porcelain <- function(x, blocks, env, base_path) {
  results <- list()
  message("Adding porcelain endpoints:")

  for (block in blocks) {
    tags <- roxygen2::block_get_tags(block, "porcelain")
    ## TODO we'd want to make sure that there is 0 or 1 here I think.
    if (length(tags) > 0L) {
      ## TODO: nice validation on these
      stopifnot(
        length(tags) == 1,
        is.function(block$object$value))
      tag <- tags[[1]]
      message(sprintf("- %s %s (%s:%d)", tag$val$method, tag$val$path,
                      basename(tag$file), tag$line))

      ## TODO could be incorrect, check by setting this
      ## alternative locations include block$object$topic and block$call[[2]]
      target <- block$object$alias

      inputs <- roxy_process_inputs(tag$val$inputs, env, tag)
      returning <- roxy_process_returning(tag$val$returning, env, tag)

      args <- c(
        list(dquote(tag$val$method), dquote(tag$val$path), target),
        inputs,
        list(sprintf("returning = %s", returning)))

      endpoint <- list_call("porcelain::porcelain_endpoint$new", args)
      results <- c(results, list(endpoint))
    }
  }

  if (length(results) == 0) {
    stop("Package contains no '@porcelain' tags")
  }

  code <- c(
    "`__porcelain__` <- function(state) {",
    paste0("  ", list_call("list", results)),
    "}")

  code
}


##' @rawNamespace S3method(roxygen2::roclet_output, roclet_porcelain)
roclet_output.roclet_porcelain <- function(x, results, base_path, ...) {
  header <- "# Generated by porcelain: do not edit by hand"

  dest <- file.path(base_path, "R", "porcelain.R")
  if (file.exists(dest)) {
    prev <- readLines(dest)
    if (length(prev) > 0 && prev[[1]] != header) {
      ## TODO: better, actionable, error
      stop("porcelain.R is not ours to change")
    }
  }

  writeLines(c(header, results), dest)

  invisible(NULL)
}


roxy_error <- function(msg, x) {
  if (!is.null(x)) {
    msg <- paste(msg,
                 sprintf("  (while processing %s:%d)", x$file, x$line),
                 sep = "\n")
  }
  stop(msg)
}


roxy_process_inputs <- function(inputs, env, x) {
  stopifnot(names(inputs) == "query") # TODO: more generalisation needed

  ## TODO: validation on query - args must be simple list
  query_type <- unname(vcapply(inputs$query, function(x) x[[1]]))
  query <- paste(sprintf('%s = "%s"', names(inputs$query), query_type),
                 collapse = ", ")
  list(sprintf("porcelain::porcelain_input_query(%s)", query))
}


roxy_process_returning <- function(returning, env, x) {
  map <- c(
    json = "porcelain::porcelain_returning_json",
    binary = "porcelain::porcelain_returning_binary",
    generic = "porcelain::porcelain_returning")
  fn <- returning[[1]]
  if (fn %in% names(map)) {
    fn <- map[[fn]]
  } else if (grepl("::", fn)) {
    fn <- fn
  } else if (!is.null(exists(fn, env, mode = "function"))) {
    fn <- fn
  } else {
    stop(sprintf("Did not find returning function '%s'", fn))
  }

  args <- paste(vcapply(returning[-1], deparse), collapse = ", ")
  sprintf("%s(%s)", fn, args)
}
